/**
 * Minified by jsDelivr using Terser v5.17.1.
 * Original file: /npm/@discordjs/collection@1.5.1/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */

const __defProp = Object.defineProperty;
const __getOwnPropDesc = Object.getOwnPropertyDescriptor;
const __getOwnPropNames = Object.getOwnPropertyNames;
const __hasOwnProp = Object.prototype.hasOwnProperty;
const __name = (t, e) => __defProp(t, 'name', { value: e, configurable: !0 });
const __export = (t, e) => {
  for (const o in e) __defProp(t, o, { get: e[o], enumerable: !0 });
};
const __copyProps = (t, e, o, r) => {
  if ((e && typeof e === 'object') || typeof e === 'function') {
    for (const n of __getOwnPropNames(e)) {
      __hasOwnProp.call(t, n) ||
        n === o ||
        __defProp(t, n, { get: () => e[n], enumerable: !(r = __getOwnPropDesc(e, n)) || r.enumerable });
    }
  }
  return t;
};
const __toCommonJS = t => __copyProps(__defProp({}, '__esModule', { value: !0 }), t);
const src_exports = {};
__export(src_exports, { Collection: () => Collection, version: () => version }),
  ({}.exports = __toCommonJS(src_exports));
var Collection = class extends Map {
  ensure(t, e) {
    if (this.has(t)) return this.get(t);
    if (typeof e !== 'function') throw new TypeError(`${e} is not a function`);
    const o = e(t, this);
    return this.set(t, o), o;
  }

  hasAll(...t) {
    return t.every(t => super.has(t));
  }

  hasAny(...t) {
    return t.some(t => super.has(t));
  }

  first(t) {
    if (void 0 === t) return this.values().next().value;
    if (t < 0) return this.last(-1 * t);
    t = Math.min(this.size, t);
    const e = this.values();
    return Array.from({ length: t }, () => e.next().value);
  }

  firstKey(t) {
    if (void 0 === t) return this.keys().next().value;
    if (t < 0) return this.lastKey(-1 * t);
    t = Math.min(this.size, t);
    const e = this.keys();
    return Array.from({ length: t }, () => e.next().value);
  }

  last(t) {
    const e = [...this.values()];
    return void 0 === t ? e[e.length - 1] : t < 0 ? this.first(-1 * t) : t ? e.slice(-t) : [];
  }

  lastKey(t) {
    const e = [...this.keys()];
    return void 0 === t ? e[e.length - 1] : t < 0 ? this.firstKey(-1 * t) : t ? e.slice(-t) : [];
  }

  at(t) {
    t = Math.floor(t);
    return [...this.values()].at(t);
  }

  keyAt(t) {
    t = Math.floor(t);
    return [...this.keys()].at(t);
  }

  random(t) {
    const e = [...this.values()];
    return void 0 === t
      ? e[Math.floor(Math.random() * e.length)]
      : e.length && t
      ? Array.from({ length: Math.min(t, e.length) }, () => e.splice(Math.floor(Math.random() * e.length), 1)[0])
      : [];
  }

  randomKey(t) {
    const e = [...this.keys()];
    return void 0 === t
      ? e[Math.floor(Math.random() * e.length)]
      : e.length && t
      ? Array.from({ length: Math.min(t, e.length) }, () => e.splice(Math.floor(Math.random() * e.length), 1)[0])
      : [];
  }

  reverse() {
    const t = [...this.entries()].reverse();
    this.clear();
    for (const [e, o] of t) this.set(e, o);
    return this;
  }

  find(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    void 0 !== e && (t = t.bind(e));
    for (const [e, o] of this) if (t(o, e, this)) return o;
  }

  findKey(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    void 0 !== e && (t = t.bind(e));
    for (const [e, o] of this) if (t(o, e, this)) return e;
  }

  sweep(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    void 0 !== e && (t = t.bind(e));
    const o = this.size;
    for (const [e, o] of this) t(o, e, this) && this.delete(e);
    return o - this.size;
  }

  filter(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    void 0 !== e && (t = t.bind(e));
    const o = new this.constructor[Symbol.species]();
    for (const [e, r] of this) t(r, e, this) && o.set(e, r);
    return o;
  }

  partition(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    void 0 !== e && (t = t.bind(e));
    const o = [new this.constructor[Symbol.species](), new this.constructor[Symbol.species]()];
    for (const [e, r] of this) t(r, e, this) ? o[0].set(e, r) : o[1].set(e, r);
    return o;
  }

  flatMap(t, e) {
    const o = this.map(t, e);
    return new this.constructor[Symbol.species]().concat(...o);
  }

  map(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    void 0 !== e && (t = t.bind(e));
    const o = this.entries();
    return Array.from({ length: this.size }, () => {
      const [e, r] = o.next().value;
      return t(r, e, this);
    });
  }

  mapValues(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    void 0 !== e && (t = t.bind(e));
    const o = new this.constructor[Symbol.species]();
    for (const [e, r] of this) o.set(e, t(r, e, this));
    return o;
  }

  some(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    void 0 !== e && (t = t.bind(e));
    for (const [e, o] of this) if (t(o, e, this)) return !0;
    return !1;
  }

  every(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    void 0 !== e && (t = t.bind(e));
    for (const [e, o] of this) if (!t(o, e, this)) return !1;
    return !0;
  }

  reduce(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    let o;
    if (void 0 !== e) {
      o = e;
      for (const [e, r] of this) o = t(o, r, e, this);
      return o;
    }
    let r = !0;
    for (const [e, n] of this) r ? ((o = n), (r = !1)) : (o = t(o, n, e, this));
    if (r) throw new TypeError('Reduce of empty collection with no initial value');
    return o;
  }

  each(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    void 0 !== e && (t = t.bind(e));
    for (const [e, o] of this) t(o, e, this);
    return this;
  }

  tap(t, e) {
    if (typeof t !== 'function') throw new TypeError(`${t} is not a function`);
    return void 0 !== e && (t = t.bind(e)), t(this), this;
  }

  clone() {
    return new this.constructor[Symbol.species](this);
  }

  concat(...t) {
    const e = this.clone();
    for (const o of t) for (const [t, r] of o) e.set(t, r);
    return e;
  }

  equals(t) {
    if (!t) return !1;
    if (this === t) return !0;
    if (this.size !== t.size) return !1;
    for (const [e, o] of this) if (!t.has(e) || o !== t.get(e)) return !1;
    return !0;
  }

  sort(t = Collection.defaultSort) {
    const e = [...this.entries()];
    e.sort((e, o) => t(e[1], o[1], e[0], o[0])), super.clear();
    for (const [t, o] of e) super.set(t, o);
    return this;
  }

  intersect(t) {
    const e = new this.constructor[Symbol.species]();
    for (const [o, r] of t) this.has(o) && Object.is(r, this.get(o)) && e.set(o, r);
    return e;
  }

  subtract(t) {
    const e = new this.constructor[Symbol.species]();
    for (const [o, r] of this) (t.has(o) && Object.is(r, t.get(o))) || e.set(o, r);
    return e;
  }

  difference(t) {
    const e = new this.constructor[Symbol.species]();
    for (const [o, r] of t) this.has(o) || e.set(o, r);
    for (const [o, r] of this) t.has(o) || e.set(o, r);
    return e;
  }

  merge(t, e, o, r) {
    const n = new this.constructor[Symbol.species]();
    const s = new Set([...this.keys(), ...t.keys()]);
    for (const i of s) {
      const s = this.has(i);
      const c = t.has(i);
      if (s && c) {
        const e = r(this.get(i), t.get(i), i);
        e.keep && n.set(i, e.value);
      } else if (s) {
        const t = e(this.get(i), i);
        t.keep && n.set(i, t.value);
      } else if (c) {
        const e = o(t.get(i), i);
        e.keep && n.set(i, e.value);
      }
    }
    return n;
  }

  sorted(t = Collection.defaultSort) {
    return new this.constructor[Symbol.species](this).sort((e, o, r, n) => t(e, o, r, n));
  }

  toJSON() {
    return [...this.values()];
  }

  static defaultSort(t, e) {
    return Number(t > e) || Number(t === e) - 1;
  }

  static combineEntries(t, e) {
    const o = new Collection();
    for (const [r, n] of t) o.has(r) ? o.set(r, e(o.get(r), n, r)) : o.set(r, n);
    return o;
  }
};
__name(Collection, 'Collection');
var version = '1.5.1';
export default Collection;
